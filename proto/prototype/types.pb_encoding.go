// Code generated by fastssz. DO NOT EDIT.
// Hash: 195e5a3e4e23dad80b811b8694b580cdbe7133c74d998fde786b5ad6c6aebaa8
// Version: 0.1.2-dev
package prototype

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(220)

	// Field (0) 'Num'
	dst = ssz.MarshalUint64(dst, b.Num)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	// Field (2) 'Version'
	if size := len(b.Version); size != 3 {
		err = ssz.ErrBytesLengthFn("Block.Version", size, 3)
		return
	}
	dst = append(dst, b.Version...)

	// Field (3) 'Hash'
	if size := len(b.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Hash", size, 32)
		return
	}
	dst = append(dst, b.Hash...)

	// Field (4) 'Parent'
	if size := len(b.Parent); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Parent", size, 32)
		return
	}
	dst = append(dst, b.Parent...)

	// Field (5) 'Timestamp'
	dst = ssz.MarshalUint64(dst, b.Timestamp)

	// Field (6) 'Txroot'
	if size := len(b.Txroot); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Txroot", size, 32)
		return
	}
	dst = append(dst, b.Txroot...)

	// Field (7) 'Proposer'
	if b.Proposer == nil {
		b.Proposer = new(Sign)
	}
	if dst, err = b.Proposer.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (8) 'Approvers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Approvers) * 85

	// Offset (9) 'Slashers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Slashers) * 85

	// Offset (10) 'Transactions'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Transactions); ii++ {
		offset += 4
		offset += b.Transactions[ii].SizeSSZ()
	}

	// Field (8) 'Approvers'
	if size := len(b.Approvers); size > 128 {
		err = ssz.ErrListTooBigFn("Block.Approvers", size, 128)
		return
	}
	for ii := 0; ii < len(b.Approvers); ii++ {
		if dst, err = b.Approvers[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (9) 'Slashers'
	if size := len(b.Slashers); size > 128 {
		err = ssz.ErrListTooBigFn("Block.Slashers", size, 128)
		return
	}
	for ii := 0; ii < len(b.Slashers); ii++ {
		if dst, err = b.Slashers[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (10) 'Transactions'
	if size := len(b.Transactions); size > 1500 {
		err = ssz.ErrListTooBigFn("Block.Transactions", size, 1500)
		return
	}
	{
		offset = 4 * len(b.Transactions)
		for ii := 0; ii < len(b.Transactions); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Transactions[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Transactions); ii++ {
		if dst, err = b.Transactions[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 220 {
		return ssz.ErrSize
	}

	tail := buf
	var o8, o9, o10 uint64

	// Field (0) 'Num'
	b.Num = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Version'
	if cap(b.Version) == 0 {
		b.Version = make([]byte, 0, len(buf[16:19]))
	}
	b.Version = append(b.Version, buf[16:19]...)

	// Field (3) 'Hash'
	if cap(b.Hash) == 0 {
		b.Hash = make([]byte, 0, len(buf[19:51]))
	}
	b.Hash = append(b.Hash, buf[19:51]...)

	// Field (4) 'Parent'
	if cap(b.Parent) == 0 {
		b.Parent = make([]byte, 0, len(buf[51:83]))
	}
	b.Parent = append(b.Parent, buf[51:83]...)

	// Field (5) 'Timestamp'
	b.Timestamp = ssz.UnmarshallUint64(buf[83:91])

	// Field (6) 'Txroot'
	if cap(b.Txroot) == 0 {
		b.Txroot = make([]byte, 0, len(buf[91:123]))
	}
	b.Txroot = append(b.Txroot, buf[91:123]...)

	// Field (7) 'Proposer'
	if b.Proposer == nil {
		b.Proposer = new(Sign)
	}
	if err = b.Proposer.UnmarshalSSZ(buf[123:208]); err != nil {
		return err
	}

	// Offset (8) 'Approvers'
	if o8 = ssz.ReadOffset(buf[208:212]); o8 > size {
		return ssz.ErrOffset
	}

	if o8 < 220 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (9) 'Slashers'
	if o9 = ssz.ReadOffset(buf[212:216]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Offset (10) 'Transactions'
	if o10 = ssz.ReadOffset(buf[216:220]); o10 > size || o9 > o10 {
		return ssz.ErrOffset
	}

	// Field (8) 'Approvers'
	{
		buf = tail[o8:o9]
		num, err := ssz.DivideInt2(len(buf), 85, 128)
		if err != nil {
			return err
		}
		b.Approvers = make([]*Sign, num)
		for ii := 0; ii < num; ii++ {
			if b.Approvers[ii] == nil {
				b.Approvers[ii] = new(Sign)
			}
			if err = b.Approvers[ii].UnmarshalSSZ(buf[ii*85 : (ii+1)*85]); err != nil {
				return err
			}
		}
	}

	// Field (9) 'Slashers'
	{
		buf = tail[o9:o10]
		num, err := ssz.DivideInt2(len(buf), 85, 128)
		if err != nil {
			return err
		}
		b.Slashers = make([]*Sign, num)
		for ii := 0; ii < num; ii++ {
			if b.Slashers[ii] == nil {
				b.Slashers[ii] = new(Sign)
			}
			if err = b.Slashers[ii].UnmarshalSSZ(buf[ii*85 : (ii+1)*85]); err != nil {
				return err
			}
		}
	}

	// Field (10) 'Transactions'
	{
		buf = tail[o10:]
		num, err := ssz.DecodeDynamicLength(buf, 1500)
		if err != nil {
			return err
		}
		b.Transactions = make([]*Transaction, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Transactions[indx] == nil {
				b.Transactions[indx] = new(Transaction)
			}
			if err = b.Transactions[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 220

	// Field (8) 'Approvers'
	size += len(b.Approvers) * 85

	// Field (9) 'Slashers'
	size += len(b.Slashers) * 85

	// Field (10) 'Transactions'
	for ii := 0; ii < len(b.Transactions); ii++ {
		size += 4
		size += b.Transactions[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Num'
	hh.PutUint64(b.Num)

	// Field (1) 'Slot'
	hh.PutUint64(b.Slot)

	// Field (2) 'Version'
	if size := len(b.Version); size != 3 {
		err = ssz.ErrBytesLengthFn("Block.Version", size, 3)
		return
	}
	hh.PutBytes(b.Version)

	// Field (3) 'Hash'
	if size := len(b.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Hash", size, 32)
		return
	}
	hh.PutBytes(b.Hash)

	// Field (4) 'Parent'
	if size := len(b.Parent); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Parent", size, 32)
		return
	}
	hh.PutBytes(b.Parent)

	// Field (5) 'Timestamp'
	hh.PutUint64(b.Timestamp)

	// Field (6) 'Txroot'
	if size := len(b.Txroot); size != 32 {
		err = ssz.ErrBytesLengthFn("Block.Txroot", size, 32)
		return
	}
	hh.PutBytes(b.Txroot)

	// Field (7) 'Proposer'
	if b.Proposer == nil {
		b.Proposer = new(Sign)
	}
	if err = b.Proposer.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (8) 'Approvers'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Approvers))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Approvers {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (9) 'Slashers'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Slashers))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Slashers {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (10) 'Transactions'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Transactions))
		if num > 1500 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Transactions {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1500)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Block object
func (b *Block) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Sign object
func (s *Sign) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Sign object to a target array
func (s *Sign) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Address'
	if size := len(s.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("Sign.Address", size, 20)
		return
	}
	dst = append(dst, s.Address...)

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 65 {
		err = ssz.ErrBytesLengthFn("Sign.Signature", size, 65)
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the Sign object
func (s *Sign) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 85 {
		return ssz.ErrSize
	}

	// Field (0) 'Address'
	if cap(s.Address) == 0 {
		s.Address = make([]byte, 0, len(buf[0:20]))
	}
	s.Address = append(s.Address, buf[0:20]...)

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[20:85]))
	}
	s.Signature = append(s.Signature, buf[20:85]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Sign object
func (s *Sign) SizeSSZ() (size int) {
	size = 85
	return
}

// HashTreeRoot ssz hashes the Sign object
func (s *Sign) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Sign object with a hasher
func (s *Sign) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Address'
	if size := len(s.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("Sign.Address", size, 20)
		return
	}
	hh.PutBytes(s.Address)

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 65 {
		err = ssz.ErrBytesLengthFn("Sign.Signature", size, 65)
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Sign object
func (s *Sign) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Transaction object
func (t *Transaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction object to a target array
func (t *Transaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(141)

	// Field (0) 'Num'
	dst = ssz.MarshalUint64(dst, t.Num)

	// Field (1) 'Type'
	dst = ssz.MarshalUint32(dst, t.Type)

	// Field (2) 'Timestamp'
	dst = ssz.MarshalUint64(dst, t.Timestamp)

	// Field (3) 'Hash'
	if size := len(t.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Transaction.Hash", size, 32)
		return
	}
	dst = append(dst, t.Hash...)

	// Field (4) 'Fee'
	dst = ssz.MarshalUint64(dst, t.Fee)

	// Offset (5) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Data)

	// Offset (6) 'Inputs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Inputs) * 64

	// Offset (7) 'Outputs'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(t.Outputs); ii++ {
		offset += 4
		offset += t.Outputs[ii].SizeSSZ()
	}

	// Field (8) 'Signature'
	if size := len(t.Signature); size != 65 {
		err = ssz.ErrBytesLengthFn("Transaction.Signature", size, 65)
		return
	}
	dst = append(dst, t.Signature...)

	// Field (9) 'Status'
	dst = ssz.MarshalUint32(dst, t.Status)

	// Field (5) 'Data'
	if size := len(t.Data); size > 1000000 {
		err = ssz.ErrBytesLengthFn("Transaction.Data", size, 1000000)
		return
	}
	dst = append(dst, t.Data...)

	// Field (6) 'Inputs'
	if size := len(t.Inputs); size > 2000 {
		err = ssz.ErrListTooBigFn("Transaction.Inputs", size, 2000)
		return
	}
	for ii := 0; ii < len(t.Inputs); ii++ {
		if dst, err = t.Inputs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'Outputs'
	if size := len(t.Outputs); size > 2000 {
		err = ssz.ErrListTooBigFn("Transaction.Outputs", size, 2000)
		return
	}
	{
		offset = 4 * len(t.Outputs)
		for ii := 0; ii < len(t.Outputs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += t.Outputs[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(t.Outputs); ii++ {
		if dst, err = t.Outputs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction object
func (t *Transaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 141 {
		return ssz.ErrSize
	}

	tail := buf
	var o5, o6, o7 uint64

	// Field (0) 'Num'
	t.Num = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Type'
	t.Type = ssz.UnmarshallUint32(buf[8:12])

	// Field (2) 'Timestamp'
	t.Timestamp = ssz.UnmarshallUint64(buf[12:20])

	// Field (3) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[20:52]))
	}
	t.Hash = append(t.Hash, buf[20:52]...)

	// Field (4) 'Fee'
	t.Fee = ssz.UnmarshallUint64(buf[52:60])

	// Offset (5) 'Data'
	if o5 = ssz.ReadOffset(buf[60:64]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 < 141 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (6) 'Inputs'
	if o6 = ssz.ReadOffset(buf[64:68]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'Outputs'
	if o7 = ssz.ReadOffset(buf[68:72]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Field (8) 'Signature'
	if cap(t.Signature) == 0 {
		t.Signature = make([]byte, 0, len(buf[72:137]))
	}
	t.Signature = append(t.Signature, buf[72:137]...)

	// Field (9) 'Status'
	t.Status = ssz.UnmarshallUint32(buf[137:141])

	// Field (5) 'Data'
	{
		buf = tail[o5:o6]
		if len(buf) > 1000000 {
			return ssz.ErrBytesLength
		}
		if cap(t.Data) == 0 {
			t.Data = make([]byte, 0, len(buf))
		}
		t.Data = append(t.Data, buf...)
	}

	// Field (6) 'Inputs'
	{
		buf = tail[o6:o7]
		num, err := ssz.DivideInt2(len(buf), 64, 2000)
		if err != nil {
			return err
		}
		t.Inputs = make([]*TxInput, num)
		for ii := 0; ii < num; ii++ {
			if t.Inputs[ii] == nil {
				t.Inputs[ii] = new(TxInput)
			}
			if err = t.Inputs[ii].UnmarshalSSZ(buf[ii*64 : (ii+1)*64]); err != nil {
				return err
			}
		}
	}

	// Field (7) 'Outputs'
	{
		buf = tail[o7:]
		num, err := ssz.DecodeDynamicLength(buf, 2000)
		if err != nil {
			return err
		}
		t.Outputs = make([]*TxOutput, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if t.Outputs[indx] == nil {
				t.Outputs[indx] = new(TxOutput)
			}
			if err = t.Outputs[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction object
func (t *Transaction) SizeSSZ() (size int) {
	size = 141

	// Field (5) 'Data'
	size += len(t.Data)

	// Field (6) 'Inputs'
	size += len(t.Inputs) * 64

	// Field (7) 'Outputs'
	for ii := 0; ii < len(t.Outputs); ii++ {
		size += 4
		size += t.Outputs[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the Transaction object
func (t *Transaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction object with a hasher
func (t *Transaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Num'
	hh.PutUint64(t.Num)

	// Field (1) 'Type'
	hh.PutUint32(t.Type)

	// Field (2) 'Timestamp'
	hh.PutUint64(t.Timestamp)

	// Field (3) 'Hash'
	if size := len(t.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Transaction.Hash", size, 32)
		return
	}
	hh.PutBytes(t.Hash)

	// Field (4) 'Fee'
	hh.PutUint64(t.Fee)

	// Field (5) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(t.Data))
		if byteLen > 1000000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(t.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1000000+31)/32)
	}

	// Field (6) 'Inputs'
	{
		subIndx := hh.Index()
		num := uint64(len(t.Inputs))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range t.Inputs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	// Field (7) 'Outputs'
	{
		subIndx := hh.Index()
		num := uint64(len(t.Outputs))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range t.Outputs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	// Field (8) 'Signature'
	if size := len(t.Signature); size != 65 {
		err = ssz.ErrBytesLengthFn("Transaction.Signature", size, 65)
		return
	}
	hh.PutBytes(t.Signature)

	// Field (9) 'Status'
	hh.PutUint32(t.Status)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Transaction object
func (t *Transaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the TxInput object
func (t *TxInput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxInput object to a target array
func (t *TxInput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	if size := len(t.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("TxInput.Hash", size, 32)
		return
	}
	dst = append(dst, t.Hash...)

	// Field (1) 'Index'
	dst = ssz.MarshalUint32(dst, t.Index)

	// Field (2) 'Address'
	if size := len(t.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("TxInput.Address", size, 20)
		return
	}
	dst = append(dst, t.Address...)

	// Field (3) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	return
}

// UnmarshalSSZ ssz unmarshals the TxInput object
func (t *TxInput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 64 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[0:32]))
	}
	t.Hash = append(t.Hash, buf[0:32]...)

	// Field (1) 'Index'
	t.Index = ssz.UnmarshallUint32(buf[32:36])

	// Field (2) 'Address'
	if cap(t.Address) == 0 {
		t.Address = make([]byte, 0, len(buf[36:56]))
	}
	t.Address = append(t.Address, buf[36:56]...)

	// Field (3) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[56:64])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxInput object
func (t *TxInput) SizeSSZ() (size int) {
	size = 64
	return
}

// HashTreeRoot ssz hashes the TxInput object
func (t *TxInput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxInput object with a hasher
func (t *TxInput) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	if size := len(t.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("TxInput.Hash", size, 32)
		return
	}
	hh.PutBytes(t.Hash)

	// Field (1) 'Index'
	hh.PutUint32(t.Index)

	// Field (2) 'Address'
	if size := len(t.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("TxInput.Address", size, 20)
		return
	}
	hh.PutBytes(t.Address)

	// Field (3) 'Amount'
	hh.PutUint64(t.Amount)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the TxInput object
func (t *TxInput) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the TxOutput object
func (t *TxOutput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxOutput object to a target array
func (t *TxOutput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(32)

	// Field (0) 'Address'
	if size := len(t.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("TxOutput.Address", size, 20)
		return
	}
	dst = append(dst, t.Address...)

	// Field (1) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	// Offset (2) 'Node'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Node)

	// Field (2) 'Node'
	if size := len(t.Node); size > 20 {
		err = ssz.ErrBytesLengthFn("TxOutput.Node", size, 20)
		return
	}
	dst = append(dst, t.Node...)

	return
}

// UnmarshalSSZ ssz unmarshals the TxOutput object
func (t *TxOutput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 32 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'Address'
	if cap(t.Address) == 0 {
		t.Address = make([]byte, 0, len(buf[0:20]))
	}
	t.Address = append(t.Address, buf[0:20]...)

	// Field (1) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[20:28])

	// Offset (2) 'Node'
	if o2 = ssz.ReadOffset(buf[28:32]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 32 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Node'
	{
		buf = tail[o2:]
		if len(buf) > 20 {
			return ssz.ErrBytesLength
		}
		if cap(t.Node) == 0 {
			t.Node = make([]byte, 0, len(buf))
		}
		t.Node = append(t.Node, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxOutput object
func (t *TxOutput) SizeSSZ() (size int) {
	size = 32

	// Field (2) 'Node'
	size += len(t.Node)

	return
}

// HashTreeRoot ssz hashes the TxOutput object
func (t *TxOutput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxOutput object with a hasher
func (t *TxOutput) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Address'
	if size := len(t.Address); size != 20 {
		err = ssz.ErrBytesLengthFn("TxOutput.Address", size, 20)
		return
	}
	hh.PutBytes(t.Address)

	// Field (1) 'Amount'
	hh.PutUint64(t.Amount)

	// Field (2) 'Node'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(t.Node))
		if byteLen > 20 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(t.Node)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (20+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the TxOutput object
func (t *TxOutput) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the Metadata object
func (m *Metadata) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the Metadata object to a target array
func (m *Metadata) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'HeadSlot'
	dst = ssz.MarshalUint64(dst, m.HeadSlot)

	// Field (1) 'HeadBlockNum'
	dst = ssz.MarshalUint64(dst, m.HeadBlockNum)

	// Field (2) 'HeadBlockHash'
	if size := len(m.HeadBlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Metadata.HeadBlockHash", size, 32)
		return
	}
	dst = append(dst, m.HeadBlockHash...)

	return
}

// UnmarshalSSZ ssz unmarshals the Metadata object
func (m *Metadata) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'HeadSlot'
	m.HeadSlot = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'HeadBlockNum'
	m.HeadBlockNum = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'HeadBlockHash'
	if cap(m.HeadBlockHash) == 0 {
		m.HeadBlockHash = make([]byte, 0, len(buf[16:48]))
	}
	m.HeadBlockHash = append(m.HeadBlockHash, buf[16:48]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Metadata object
func (m *Metadata) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the Metadata object
func (m *Metadata) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the Metadata object with a hasher
func (m *Metadata) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'HeadSlot'
	hh.PutUint64(m.HeadSlot)

	// Field (1) 'HeadBlockNum'
	hh.PutUint64(m.HeadBlockNum)

	// Field (2) 'HeadBlockHash'
	if size := len(m.HeadBlockHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Metadata.HeadBlockHash", size, 32)
		return
	}
	hh.PutBytes(m.HeadBlockHash)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Metadata object
func (m *Metadata) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the BlockRequest object
func (b *BlockRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockRequest object to a target array
func (b *BlockRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'StartSlot'
	dst = ssz.MarshalUint64(dst, b.StartSlot)

	// Field (1) 'Count'
	dst = ssz.MarshalUint64(dst, b.Count)

	// Field (2) 'Step'
	dst = ssz.MarshalUint64(dst, b.Step)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockRequest object
func (b *BlockRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 24 {
		return ssz.ErrSize
	}

	// Field (0) 'StartSlot'
	b.StartSlot = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Count'
	b.Count = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Step'
	b.Step = ssz.UnmarshallUint64(buf[16:24])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockRequest object
func (b *BlockRequest) SizeSSZ() (size int) {
	size = 24
	return
}

// HashTreeRoot ssz hashes the BlockRequest object
func (b *BlockRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockRequest object with a hasher
func (b *BlockRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'StartSlot'
	hh.PutUint64(b.StartSlot)

	// Field (1) 'Count'
	hh.PutUint64(b.Count)

	// Field (2) 'Step'
	hh.PutUint64(b.Step)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockRequest object
func (b *BlockRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}
