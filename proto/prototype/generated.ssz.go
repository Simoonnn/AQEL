// Code generated by fastssz. DO NOT EDIT.
// Hash: a0cf792c3c4bc2ec71040484563bfccc58d70576594629e6f31d9fbce1041b43
package prototype

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(143)

	// Field (0) 'Num'
	dst = ssz.MarshalUint64(dst, b.Num)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	// Field (2) 'Version'
	if len(b.Version) != 3 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Version...)

	// Field (3) 'Hash'
	if len(b.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Hash...)

	// Field (4) 'Parent'
	if len(b.Parent) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Parent...)

	// Field (5) 'Timestamp'
	dst = ssz.MarshalUint64(dst, b.Timestamp)

	// Field (6) 'Txroot'
	if len(b.Txroot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Txroot...)

	// Field (7) 'Size'
	dst = ssz.MarshalUint32(dst, b.Size)

	// Offset (8) 'Proposer'
	dst = ssz.WriteOffset(dst, offset)
	if b.Proposer == nil {
		b.Proposer = new(Sign)
	}
	offset += b.Proposer.SizeSSZ()

	// Offset (9) 'Approvers'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Approvers); ii++ {
		offset += 4
		offset += b.Approvers[ii].SizeSSZ()
	}

	// Offset (10) 'Slashers'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Slashers); ii++ {
		offset += 4
		offset += b.Slashers[ii].SizeSSZ()
	}

	// Offset (11) 'Transactions'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Transactions); ii++ {
		offset += 4
		offset += b.Transactions[ii].SizeSSZ()
	}

	// Field (8) 'Proposer'
	if dst, err = b.Proposer.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (9) 'Approvers'
	if len(b.Approvers) > 128 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(b.Approvers)
		for ii := 0; ii < len(b.Approvers); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Approvers[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Approvers); ii++ {
		if dst, err = b.Approvers[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (10) 'Slashers'
	if len(b.Slashers) > 128 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(b.Slashers)
		for ii := 0; ii < len(b.Slashers); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Slashers[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Slashers); ii++ {
		if dst, err = b.Slashers[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'Transactions'
	if len(b.Transactions) > 1000 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(b.Transactions)
		for ii := 0; ii < len(b.Transactions); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Transactions[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Transactions); ii++ {
		if dst, err = b.Transactions[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 143 {
		return ssz.ErrSize
	}

	tail := buf
	var o8, o9, o10, o11 uint64

	// Field (0) 'Num'
	b.Num = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Version'
	if cap(b.Version) == 0 {
		b.Version = make([]byte, 0, len(buf[16:19]))
	}
	b.Version = append(b.Version, buf[16:19]...)

	// Field (3) 'Hash'
	if cap(b.Hash) == 0 {
		b.Hash = make([]byte, 0, len(buf[19:51]))
	}
	b.Hash = append(b.Hash, buf[19:51]...)

	// Field (4) 'Parent'
	if cap(b.Parent) == 0 {
		b.Parent = make([]byte, 0, len(buf[51:83]))
	}
	b.Parent = append(b.Parent, buf[51:83]...)

	// Field (5) 'Timestamp'
	b.Timestamp = ssz.UnmarshallUint64(buf[83:91])

	// Field (6) 'Txroot'
	if cap(b.Txroot) == 0 {
		b.Txroot = make([]byte, 0, len(buf[91:123]))
	}
	b.Txroot = append(b.Txroot, buf[91:123]...)

	// Field (7) 'Size'
	b.Size = ssz.UnmarshallUint32(buf[123:127])

	// Offset (8) 'Proposer'
	if o8 = ssz.ReadOffset(buf[127:131]); o8 > size {
		return ssz.ErrOffset
	}

	if o8 < 143 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (9) 'Approvers'
	if o9 = ssz.ReadOffset(buf[131:135]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Offset (10) 'Slashers'
	if o10 = ssz.ReadOffset(buf[135:139]); o10 > size || o9 > o10 {
		return ssz.ErrOffset
	}

	// Offset (11) 'Transactions'
	if o11 = ssz.ReadOffset(buf[139:143]); o11 > size || o10 > o11 {
		return ssz.ErrOffset
	}

	// Field (8) 'Proposer'
	{
		buf = tail[o8:o9]
		if b.Proposer == nil {
			b.Proposer = new(Sign)
		}
		if err = b.Proposer.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (9) 'Approvers'
	{
		buf = tail[o9:o10]
		num, err := ssz.DecodeDynamicLength(buf, 128)
		if err != nil {
			return err
		}
		b.Approvers = make([]*Sign, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Approvers[indx] == nil {
				b.Approvers[indx] = new(Sign)
			}
			if err = b.Approvers[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (10) 'Slashers'
	{
		buf = tail[o10:o11]
		num, err := ssz.DecodeDynamicLength(buf, 128)
		if err != nil {
			return err
		}
		b.Slashers = make([]*Sign, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Slashers[indx] == nil {
				b.Slashers[indx] = new(Sign)
			}
			if err = b.Slashers[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (11) 'Transactions'
	{
		buf = tail[o11:]
		num, err := ssz.DecodeDynamicLength(buf, 1000)
		if err != nil {
			return err
		}
		b.Transactions = make([]*Transaction, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Transactions[indx] == nil {
				b.Transactions[indx] = new(Transaction)
			}
			if err = b.Transactions[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 143

	// Field (8) 'Proposer'
	if b.Proposer == nil {
		b.Proposer = new(Sign)
	}
	size += b.Proposer.SizeSSZ()

	// Field (9) 'Approvers'
	for ii := 0; ii < len(b.Approvers); ii++ {
		size += 4
		size += b.Approvers[ii].SizeSSZ()
	}

	// Field (10) 'Slashers'
	for ii := 0; ii < len(b.Slashers); ii++ {
		size += 4
		size += b.Slashers[ii].SizeSSZ()
	}

	// Field (11) 'Transactions'
	for ii := 0; ii < len(b.Transactions); ii++ {
		size += 4
		size += b.Transactions[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Num'
	hh.PutUint64(b.Num)

	// Field (1) 'Slot'
	hh.PutUint64(b.Slot)

	// Field (2) 'Version'
	if len(b.Version) != 3 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.Version)

	// Field (3) 'Hash'
	if len(b.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.Hash)

	// Field (4) 'Parent'
	if len(b.Parent) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.Parent)

	// Field (5) 'Timestamp'
	hh.PutUint64(b.Timestamp)

	// Field (6) 'Txroot'
	if len(b.Txroot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.Txroot)

	// Field (7) 'Size'
	hh.PutUint32(b.Size)

	// Field (8) 'Proposer'
	if err = b.Proposer.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'Approvers'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Approvers))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for i := uint64(0); i < num; i++ {
			if err = b.Approvers[i].HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (10) 'Slashers'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Slashers))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for i := uint64(0); i < num; i++ {
			if err = b.Slashers[i].HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (11) 'Transactions'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Transactions))
		if num > 1000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for i := uint64(0); i < num; i++ {
			if err = b.Transactions[i].HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1000)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Transaction object
func (t *Transaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction object to a target array
func (t *Transaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(76)

	// Field (0) 'Num'
	dst = ssz.MarshalUint64(dst, t.Num)

	// Field (1) 'Type'
	dst = ssz.MarshalUint32(dst, t.Type)

	// Field (2) 'Timestamp'
	dst = ssz.MarshalUint64(dst, t.Timestamp)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Hash...)

	// Field (4) 'Fee'
	dst = ssz.MarshalUint64(dst, t.Fee)

	// Field (5) 'Size'
	dst = ssz.MarshalUint32(dst, t.Size)

	// Offset (6) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Data)

	// Offset (7) 'Inputs'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(t.Inputs); ii++ {
		offset += 4
		offset += t.Inputs[ii].SizeSSZ()
	}

	// Offset (8) 'Outputs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Outputs) * 40

	// Field (6) 'Data'
	if len(t.Data) > 10000 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Data...)

	// Field (7) 'Inputs'
	if len(t.Inputs) > 100000 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(t.Inputs)
		for ii := 0; ii < len(t.Inputs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += t.Inputs[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(t.Inputs); ii++ {
		if dst, err = t.Inputs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (8) 'Outputs'
	if len(t.Outputs) > 30 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(t.Outputs); ii++ {
		if dst, err = t.Outputs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction object
func (t *Transaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 76 {
		return ssz.ErrSize
	}

	tail := buf
	var o6, o7, o8 uint64

	// Field (0) 'Num'
	t.Num = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Type'
	t.Type = ssz.UnmarshallUint32(buf[8:12])

	// Field (2) 'Timestamp'
	t.Timestamp = ssz.UnmarshallUint64(buf[12:20])

	// Field (3) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[20:52]))
	}
	t.Hash = append(t.Hash, buf[20:52]...)

	// Field (4) 'Fee'
	t.Fee = ssz.UnmarshallUint64(buf[52:60])

	// Field (5) 'Size'
	t.Size = ssz.UnmarshallUint32(buf[60:64])

	// Offset (6) 'Data'
	if o6 = ssz.ReadOffset(buf[64:68]); o6 > size {
		return ssz.ErrOffset
	}

	if o6 < 76 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (7) 'Inputs'
	if o7 = ssz.ReadOffset(buf[68:72]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Offset (8) 'Outputs'
	if o8 = ssz.ReadOffset(buf[72:76]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Field (6) 'Data'
	{
		buf = tail[o6:o7]
		if len(buf) > 10000 {
			return ssz.ErrBytesLength
		}
		if cap(t.Data) == 0 {
			t.Data = make([]byte, 0, len(buf))
		}
		t.Data = append(t.Data, buf...)
	}

	// Field (7) 'Inputs'
	{
		buf = tail[o7:o8]
		num, err := ssz.DecodeDynamicLength(buf, 100000)
		if err != nil {
			return err
		}
		t.Inputs = make([]*TxInput, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if t.Inputs[indx] == nil {
				t.Inputs[indx] = new(TxInput)
			}
			if err = t.Inputs[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (8) 'Outputs'
	{
		buf = tail[o8:]
		num, err := ssz.DivideInt2(len(buf), 40, 30)
		if err != nil {
			return err
		}
		t.Outputs = make([]*TxOutput, num)
		for ii := 0; ii < num; ii++ {
			if t.Outputs[ii] == nil {
				t.Outputs[ii] = new(TxOutput)
			}
			if err = t.Outputs[ii].UnmarshalSSZ(buf[ii*40 : (ii+1)*40]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction object
func (t *Transaction) SizeSSZ() (size int) {
	size = 76

	// Field (6) 'Data'
	size += len(t.Data)

	// Field (7) 'Inputs'
	for ii := 0; ii < len(t.Inputs); ii++ {
		size += 4
		size += t.Inputs[ii].SizeSSZ()
	}

	// Field (8) 'Outputs'
	size += len(t.Outputs) * 40

	return
}

// HashTreeRoot ssz hashes the Transaction object
func (t *Transaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction object with a hasher
func (t *Transaction) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Num'
	hh.PutUint64(t.Num)

	// Field (1) 'Type'
	hh.PutUint32(t.Type)

	// Field (2) 'Timestamp'
	hh.PutUint64(t.Timestamp)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Hash)

	// Field (4) 'Fee'
	hh.PutUint64(t.Fee)

	// Field (5) 'Size'
	hh.PutUint32(t.Size)

	// Field (6) 'Data'
	if len(t.Data) > 10000 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Data)

	// Field (7) 'Inputs'
	{
		subIndx := hh.Index()
		num := uint64(len(t.Inputs))
		if num > 100000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for i := uint64(0); i < num; i++ {
			if err = t.Inputs[i].HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 100000)
	}

	// Field (8) 'Outputs'
	{
		subIndx := hh.Index()
		num := uint64(len(t.Outputs))
		if num > 30 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for i := uint64(0); i < num; i++ {
			if err = t.Outputs[i].HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 30)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxInput object
func (t *TxInput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxInput object to a target array
func (t *TxInput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(80)

	// Field (0) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Hash...)

	// Field (1) 'Index'
	dst = ssz.MarshalUint32(dst, t.Index)

	// Field (2) 'Address'
	if len(t.Address) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Address...)

	// Field (3) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	// Offset (4) 'Sign'
	dst = ssz.WriteOffset(dst, offset)
	if t.Sign == nil {
		t.Sign = new(Sign)
	}
	offset += t.Sign.SizeSSZ()

	// Field (4) 'Sign'
	if dst, err = t.Sign.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the TxInput object
func (t *TxInput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 80 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[0:32]))
	}
	t.Hash = append(t.Hash, buf[0:32]...)

	// Field (1) 'Index'
	t.Index = ssz.UnmarshallUint32(buf[32:36])

	// Field (2) 'Address'
	if cap(t.Address) == 0 {
		t.Address = make([]byte, 0, len(buf[36:68]))
	}
	t.Address = append(t.Address, buf[36:68]...)

	// Field (3) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[68:76])

	// Offset (4) 'Sign'
	if o4 = ssz.ReadOffset(buf[76:80]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 80 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Sign'
	{
		buf = tail[o4:]
		if t.Sign == nil {
			t.Sign = new(Sign)
		}
		if err = t.Sign.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxInput object
func (t *TxInput) SizeSSZ() (size int) {
	size = 80

	// Field (4) 'Sign'
	if t.Sign == nil {
		t.Sign = new(Sign)
	}
	size += t.Sign.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the TxInput object
func (t *TxInput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxInput object with a hasher
func (t *TxInput) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Hash)

	// Field (1) 'Index'
	hh.PutUint32(t.Index)

	// Field (2) 'Address'
	if len(t.Address) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Address)

	// Field (3) 'Amount'
	hh.PutUint64(t.Amount)

	// Field (4) 'Sign'
	if err = t.Sign.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxOutput object
func (t *TxOutput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxOutput object to a target array
func (t *TxOutput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Address'
	if len(t.Address) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Address...)

	// Field (1) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	return
}

// UnmarshalSSZ ssz unmarshals the TxOutput object
func (t *TxOutput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 40 {
		return ssz.ErrSize
	}

	// Field (0) 'Address'
	if cap(t.Address) == 0 {
		t.Address = make([]byte, 0, len(buf[0:32]))
	}
	t.Address = append(t.Address, buf[0:32]...)

	// Field (1) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[32:40])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxOutput object
func (t *TxOutput) SizeSSZ() (size int) {
	size = 40
	return
}

// HashTreeRoot ssz hashes the TxOutput object
func (t *TxOutput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxOutput object with a hasher
func (t *TxOutput) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Address'
	if len(t.Address) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Address)

	// Field (1) 'Amount'
	hh.PutUint64(t.Amount)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Sign object
func (s *Sign) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Sign object to a target array
func (s *Sign) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signature)

	// Field (0) 'Signature'
	if len(s.Signature) > 97 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the Sign object
func (s *Sign) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Signature'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Signature'
	{
		buf = tail[o0:]
		if len(buf) > 97 {
			return ssz.ErrBytesLength
		}
		if cap(s.Signature) == 0 {
			s.Signature = make([]byte, 0, len(buf))
		}
		s.Signature = append(s.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Sign object
func (s *Sign) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Signature'
	size += len(s.Signature)

	return
}

// HashTreeRoot ssz hashes the Sign object
func (s *Sign) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Sign object with a hasher
func (s *Sign) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Signature'
	if len(s.Signature) > 97 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}
